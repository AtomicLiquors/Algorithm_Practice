<aside>
💡
잘 이해하면 쉽지만 어설프게 배우면 헷갈릴 수 있습니다.
</aside>

<br>

### 다익스트라
- 시작 정점에서 **다른 모든 정점**까지 최단 경로를 구하는 알고리즘.
- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식.

<br>

### 탐욕법을 사용한다.
- 다익스트라는 항상 **가중치가 양수인 상황**만 고려한다.
    - **음수가 있다면 앞전의 선택도 뒤집어질 수 있기 때문이다.**
    - 예를 들어 처음에 10, 11 중 10을 골랐는데, 
    11이 -2 간선과 연결되어 있었던 경우 11이 최선의 선택이 되어 버린다.
- **“단 한 번 최선의 선택을 하고 돌아가지 않는 것” 그것이 탐욕법이다.**
- 더 탐색해 봤자 비용이 늘어날 게 뻔하니까 방문한 정점들은 배제한다. (중요)

### 알고리즘 구조
- 주어지는 것 : 정점, 연결 정보

#### 자료구조 생성
1. 정점 개수만큼 정수 배열 ```distance```을 생성한다.
   출발지점에서 자신까지 오는 비용이다. 임의의 최댓값으로 채워넣는다.
2. 정점 개수만큼 ```boolean``` 배열 ```visited```를 생성한다.
   해당 정점이 경유지로 고려되었는지를 나타낸다.

#### 알고리즘 실행
**모든 정점**을 돌면서 
- 경유지에 포함되지 않은 정점 중, 출발지에서 가장 가까운 정점 선택
- 다른 미방문 인접 정점에 대해, 위에서 선택된 정점을 경유한 경우를 반영하여 비용 최솟값 갱신

출발지 ```start```, 도착지 ```end```를 사용한다.
1. 출발지-출발지의 거리는 0이다. 따라서 루프에 진입하기 전 ```distance[start] = 0```으로 박는다.
2. 루프문 내부에서 사용할 두 개의 정수 변수 ```min```, ```current```를 선언한다.
3. 모든 정점에 대해 루프를 시작한다.
   3-1. ```min```을 임의의 최댓값으로 초기화한다. 
        ```current```를 정점이 선택되지 않았음을 나타내는 임의의 수(-1)로 초기화한다.
   3-2. 모든 정점에 대해 중첩 루프를 시작한다.
       **"경유지에 포함되지 않은 정점 중, 출발지에서 가장 가까운 정점 선택"**
       3-2-1. 현재 정점이 ```visited```배열에서 ```false```인지 확인, 
              동시에 현재 정점에 대한 ```distance``` 값보다 ```min```값이 큰지 확인.
       3-2-2. 둘 다 해당된다면
               - ```min```에는 현재 거리 값을 대입한다.
               - ```current```에는 현재 정점을 대입한다.
   3-3. 3-2의 결과 아무것도 선택되지 않았다(```current == -1```) -> 루프 break.
   3-4. 3-3을 통과했다면, 다시 말해 무언가 하나 선택되었다면
        이 정점을 경유지로 삼겠다.
        ```visited[current] = true```
   3-5. 이 정점이 도착점이라면(```current == end```) 루프 break.
   3-6. 모든 정점에 대해 중첩 루프를 시작한다.
         **다른 미방문 인접 정점에 대해, 위에서 선택된 정점을 경유한 경우를 반영하여 비용 최솟값 갱신**
         3-6-1. 현재 정점에 대해 ```!visited```고, 선택된 정점(```current```)와 현재 정점의 거리가 0이 아닌지 확인.
         3-6-2. 둘 다 해당된다면 현재 정점에 대한 ```distance```값을 (```min```값 + 선택된 정점과 현재 정점의 거리)와 비교하여 최솟값 갱신
   3-7. 다음 정점에 대해 전 과정 반복.
   
   
