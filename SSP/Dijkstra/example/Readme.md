## 반복문 사용 다익스트라


### 알고리즘 구조
- 주어지는 것 : 정점, 연결 정보

#### 자료구조 생성
1. 정점 개수만큼 정수 배열 ```distance```을 생성한다.
   출발지점에서 자신까지 오는 비용이다. 임의의 최댓값으로 채워넣는다.
2. 정점 개수만큼 ```boolean``` 배열 ```visited```를 생성한다.
   해당 정점이 경유지로 고려되었는지를 나타낸다.

#### 알고리즘 실행
**모든 정점**을 돌면서 
- 경유지에 포함되지 않은 정점 중, 출발지에서 가장 가까운 정점 선택
- 다른 미방문 인접 정점에 대해, 위에서 선택된 정점을 경유한 경우를 반영하여 비용 최솟값 갱신

출발지 ```start```, 도착지 ```end```를 사용한다.  
1. 출발지-출발지의 거리는 0이다. 따라서 루프에 진입하기 전 ```distance[start] = 0```으로 박는다.  
2. 루프문 내부에서 사용할 두 개의 정수 변수 ```min```, ```current```를 선언한다.  
3. 모든 정점에 대해 루프를 시작한다.  
   3-1. ```min```을 임의의 최댓값으로 초기화한다.   
        ```current```를 정점이 선택되지 않았음을 나타내는 임의의 수(-1)로 초기화한다.  
   3-2. 모든 정점에 대해 중첩 루프를 시작한다.  
       **"경유지에 포함되지 않은 정점 중, 출발지에서 가장 가까운 정점 선택"**  
       3-2-1. a) 현재 정점에 대해 ```!visited```인지 방문 체크.
              b) 현재 정점에 대한 ```distance``` 값이 ```min```보다도 작은지 확인.  
       3-2-2. a), b) 둘 다 해당된다면  
               - ```min```에는 현재 거리 값을 대입한다.  
               - ```current```에는 현재 정점을 대입한다.  
   3-3. 3-2의 결과 아무것도 선택되지 않았다(```current == -1```) -> 루프 break.  
   3-4. 3-3을 통과했다면, 다시 말해 무언가 하나 선택되었다면  
        이 정점을 경유지로 삼겠다.  
        ```visited[current] = true```  
   3-5. 이 정점이 도착점이라면(```current == end```) 루프 break.  
   3-6. 모든 정점에 대해 중첩 루프를 시작한다.  
         **다른 미방문 인접 정점에 대해, 위에서 선택된 정점을 경유한 경우를 반영하여 비용 최솟값 갱신**  
         3-6-1. a) 현재 정점에 대해 ```!visited```인지 방문 체크.
                b) 인접 배열에서 선택된 정점(```current```)와 현재 정점의 거리를 확인, 0이 아니라는 것을 체크.
         3-6-2. a), b) 둘 다 해당된다면 현재 정점에 대한 ```distance```값을 (```min```값 + 인접 배열에서의 선택 정점 ```current```과 현재 정점의 거리)와 비교하여 최솟값 갱신  
   3-7. 다음 정점에 대해 전 과정 반복.
